Here’s the **ready-to-paste script** you can drop directly into the Replit Agent.
It contains exact commands, file scaffolding, and starter boilerplate so it can immediately start refactoring your **ClientConnect** repo.

---

## **Replit Agent — Refactor Script for ClientConnect**

**Instructions for Agent:**
Follow each step in order. Use the given commands to create folders/files, move logic, and insert boilerplate code. Keep existing functionality working after each phase.

---

### **1. Create New Backend Structure**

```bash
# Create new folders for better separation of concerns
mkdir -p server/{controllers,services,middlewares,workers}
```

---

### **2. Install Dependencies**

```bash
# Backend dependencies
npm install zod pino bullmq ioredis jsonwebtoken aws-sdk multer-s3 @sentry/node express-rate-limit

# Frontend dependencies
cd client && npm install zustand @sentry/react && cd ..
```

---

### **3. Backend Boilerplate Files**

#### `server/middlewares/errorHandler.ts`

```ts
import { Request, Response, NextFunction } from "express";

export function errorHandler(err: any, req: Request, res: Response, _next: NextFunction) {
  console.error(err);
  res.status(err.status || 500).json({
    success: false,
    message: err.message || "Internal Server Error",
  });
}
```

#### `server/middlewares/validateRequest.ts`

```ts
import { AnyZodObject } from "zod";
import { Request, Response, NextFunction } from "express";

export const validateRequest = (schema: AnyZodObject) => (req: Request, res: Response, next: NextFunction) => {
  try {
    schema.parse({ body: req.body, params: req.params, query: req.query });
    next();
  } catch (err: any) {
    res.status(400).json({ success: false, message: err.errors });
  }
};
```

#### `server/middlewares/rateLimit.ts`

```ts
import rateLimit from "express-rate-limit";

export const loginRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: "Too many login attempts, please try again later",
});
```

---

### **4. Service Example**

#### `server/services/fileService.ts`

```ts
import AWS from "aws-sdk";
import { v4 as uuid } from "uuid";

const s3 = new AWS.S3({
  region: process.env.S3_REGION,
  accessKeyId: process.env.S3_ACCESS_KEY_ID,
  secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,
});

export async function generateUploadURL(filename: string, mimeType: string) {
  const Key = `${uuid()}-${filename}`;
  return s3.getSignedUrlPromise("putObject", {
    Bucket: process.env.S3_BUCKET!,
    Key,
    ContentType: mimeType,
    Expires: 300, // 5 min
  });
}
```

---

### **5. Frontend Store Example**

#### `client/src/stores/useAuthStore.ts`

```ts
import create from "zustand";

type AuthState = {
  user: any;
  setUser: (u: any) => void;
  clearUser: () => void;
};

export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  setUser: (u) => set({ user: u }),
  clearUser: () => set({ user: null }),
}));
```

---

### **6. Background Worker Example**

#### `server/workers/thumbnailWorker.ts`

```ts
import { Worker } from "bullmq";

const connection = { connection: { url: process.env.REDIS_URL! } };

const thumbnailWorker = new Worker("thumbnails", async (job) => {
  console.log("Processing thumbnail for file:", job.data.fileKey);
  // TODO: Implement thumbnail generation
}, connection);

export default thumbnailWorker;
```

---

### **7. Update `.env.example`**

```env
DATABASE_URL=postgres://user:password@host:5432/dbname
SESSION_SECRET=supersecret
S3_BUCKET=my-bucket
S3_REGION=us-east-1
S3_ACCESS_KEY_ID=YOUR_KEY
S3_SECRET_ACCESS_KEY=YOUR_SECRET
REDIS_URL=redis://localhost:6379
```

---

### **8. Final Integration Steps**

* Replace existing Multer local upload config with `multer-s3` using `fileService`.
* Update file upload routes to generate a signed URL instead of storing files locally.
* Move all route logic into `controllers/` that call the `services/`.
* Apply `validateRequest` to all routes with Zod schemas.
* Add `errorHandler` middleware last in the `app.use()` chain.
* Wrap large frontend pages in `React.lazy` + `Suspense`.
* Replace repeated `fetch("/api/auth/user")` calls with `useAuthStore`.

---

✅ **After this script, the codebase will be modular, secure, and ready for scaling beyond Replit.**

---

If you want, I can also prepare a **branching strategy** so the Replit Agent implements this in **stages** without breaking production.
That would help if you want to keep your current app live while refactoring.
Do you want me to add that?
